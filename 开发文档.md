# Rosetta Connect 开发文档

## 📋 目录

- [项目概述](#项目概述)
- [技术架构](#技术架构)
- [开发环境配置](#开发环境配置)
- [项目结构](#项目结构)
- [核心模块详解](#核心模块详解)
- [开发指南](#开发指南)
- [编码规范](#编码规范)
- [测试策略](#测试策略)
- [部署和发布](#部署和发布)
- [贡献指南](#贡献指南)
- [常见问题](#常见问题)

---

## 🎯 项目概述

**Rosetta Connect** 是一个基于 Rust 构建的 CLI 工具，专为 iOS 应用的 App Store Connect 本地化工作流程自动化设计。

### 核心价值

- **🚀 高性能**: 基于 Rust，零运行时开销
- **🤖 AI 驱动**: 集成 OpenAI GPT 进行智能翻译
- **📱 完整工作流**: 拉取→翻译→审查→推送的一站式解决方案
- **🔧 零配置**: 开箱即用，内嵌 Node.js 运行时

### 技术特色

- **混合架构**: Rust 核心 + 嵌入式 Node.js 边车
- **异步优先**: 基于 Tokio 的全异步处理
- **类型安全**: 跨语言边界的强类型保证
- **单一二进制**: 无外部依赖的独立可执行文件

---

## 🏗️ 技术架构

### 架构概览

```
┌─────────────────────────────────────────────────────────────┐
│                     Rosetta Connect                        │
├─────────────────┬─────────────────┬─────────────────────────┤
│   CLI 层        │   核心逻辑层     │      集成层             │
│                 │                 │                         │
│ ┌─────────────┐ │ ┌─────────────┐ │ ┌─────────────────────┐ │
│ │    clap     │ │ │   Config    │ │ │    Node.js Bridge   │ │
│ │  Commands   │ │ │  Manager    │ │ │     (napi-rs)       │ │
│ └─────────────┘ │ └─────────────┘ │ └─────────────────────┘ │
│                 │                 │                         │
│ ┌─────────────┐ │ ┌─────────────┐ │ ┌─────────────────────┐ │
│ │ Progress    │ │ │ Translation │ │ │ App Store Connect   │ │
│ │   UI        │ │ │   Engine    │ │ │       SDK           │ │
│ └─────────────┘ │ └─────────────┘ │ └─────────────────────┘ │
│                 │                 │                         │
│                 │ ┌─────────────┐ │ ┌─────────────────────┐ │
│                 │ │  File I/O   │ │ │    OpenAI API       │ │
│                 │ │  Manager    │ │ │     (HTTP)          │ │
│                 │ └─────────────┘ │ └─────────────────────┘ │
└─────────────────┴─────────────────┴─────────────────────────┘
```

### 技术栈详解

| 层级 | 技术组件 | 说明 |
|------|----------|------|
| **CLI 框架** | clap v4, color-eyre | 命令行参数解析和美观的错误报告 |
| **异步运行时** | tokio v1, futures | 高性能异步 I/O 和并发处理 |
| **Node.js 集成** | napi-rs, edon | 嵌入式 Node.js 运行时和 FFI 桥接 |
| **配置管理** | serde, toml | 类型安全的配置序列化和反序列化 |
| **HTTP 客户端** | reqwest, openai-rs | RESTful API 交互和 AI 服务集成 |
| **用户界面** | indicatif, console | 进度条、颜色输出和交互式 UI |

---

## ⚙️ 开发环境配置

### 系统要求

- **Rust**: 1.70+ (使用 `rustup` 安装)
- **Node.js**: 18+ (仅开发时需要)
- **Git**: 最新版本
- **操作系统**: macOS, Linux, Windows

### 快速开始

```bash
# 1. 克隆项目
git clone https://github.com/yourusername/rosetta-connect.git
cd rosetta-connect

# 2. 安装 Rust 工具链
rustup update stable
rustup default stable

# 3. 安装必要的 Rust 工具
cargo install cargo-watch cargo-audit cargo-udeps

# 4. 构建项目
cargo build

# 5. 运行测试
cargo test

# 6. 本地开发构建
cargo build --release --features bundled-node
```

### 开发工具配置

#### VSCode 推荐扩展

```json
{
  "recommendations": [
    "rust-lang.rust-analyzer",
    "vadimcn.vscode-lldb",
    "serayuzgur.crates",
    "tamasfe.even-better-toml"
  ]
}
```

#### Rust 工具链设置

```bash
# 安装组件
rustup component add clippy rustfmt rust-src

# 设置工具配置
echo 'edition = "2021"' >> Cargo.toml
```

---

## 📁 项目结构

```
rosetta-connect/
├── 📁 crates/                    # Rust 工作空间
│   ├── 📁 rc-cli/                # 主 CLI 应用
│   │   ├── 📄 Cargo.toml         # CLI 依赖配置
│   │   └── 📁 src/
│   │       ├── 📄 main.rs        # 程序入口点
│   │       ├── 📄 config.rs      # 配置管理
│   │       └── 📁 commands/      # 命令实现
│   │           ├── 📄 mod.rs     # 命令模块声明
│   │           ├── 📄 init.rs    # 初始化命令
│   │           ├── 📄 pull.rs    # 拉取命令
│   │           ├── 📄 translate.rs # 翻译命令
│   │           ├── 📄 push.rs    # 推送命令
│   │           └── 📄 ...        # 其他命令
│   └── 📁 rc-node/               # Node.js 桥接层
│       ├── 📄 Cargo.toml         # 桥接层依赖
│       └── 📁 src/
│           └── 📄 lib.rs         # NAPI 绑定
├── 📁 js/                        # JavaScript/TypeScript 源码
│   └── 📄 asc.ts                 # App Store Connect SDK 封装
├── 📁 help-center/               # 用户文档
├── 📁 test-demo/                 # 测试和演示
├── 📄 Cargo.toml                 # 工作空间配置
├── 📄 rosetta.toml               # 项目配置模板
├── 📄 开发文档.md                 # 本文档
└── 📄 README.md                  # 项目介绍
```

### 核心文件说明

| 文件 | 作用 | 重要性 |
|------|------|--------|
| `crates/rc-cli/src/main.rs` | CLI 程序入口，命令路由 | ⭐⭐⭐⭐⭐ |
| `crates/rc-cli/src/config.rs` | 配置结构定义和管理 | ⭐⭐⭐⭐ |
| `crates/rc-node/src/lib.rs` | Rust-Node.js 桥接层 | ⭐⭐⭐⭐ |
| `js/asc.ts` | App Store Connect API 封装 | ⭐⭐⭐⭐ |
| `rosetta.toml` | 用户项目配置文件 | ⭐⭐⭐ |

---

## 🔧 核心模块详解

### 1. 配置管理系统 (`config.rs`)

```rust
#[derive(Debug, Serialize, Deserialize)]
pub struct Config {
    pub app: AppConfig,
    pub assets: Option<AssetsConfig>,
    pub ai: Option<AiConfig>,
}
```

**设计原则**:
- 使用 `serde` 确保类型安全的序列化
- 支持可选配置项（`Option<T>`）
- 提供合理的默认值
- 支持环境变量覆盖

**配置加载优先级**:
1. 命令行参数
2. 环境变量
3. `rosetta.toml` 文件
4. 内置默认值

### 2. 命令系统 (`commands/`)

每个命令模块遵循统一接口：

```rust
pub async fn run(/* 参数 */, config_path: &Path) -> anyhow::Result<()> {
    // 1. 加载配置
    let config = Config::load(config_path)?;
    
    // 2. 验证参数
    validate_params()?;
    
    // 3. 执行核心逻辑
    execute_core_logic().await?;
    
    // 4. 输出结果
    display_results()?;
    
    Ok(())
}
```

### 3. Node.js 桥接层 (`rc-node`)

```rust
#[napi]
pub async fn asc_upload(metadata: JsObject) -> napi::Result<JsObject> {
    // 调用嵌入的 Node.js 函数
}
```

**桥接策略**:
- 使用 `napi-rs` 进行类型安全的数据传递
- 所有异步操作返回 `Promise`
- 错误处理统一映射到 Rust 类型

---

## 💻 开发指南

### 开发工作流

1. **功能分支**: 从 `main` 创建功能分支
2. **本地开发**: 使用 `cargo watch` 进行热重载
3. **代码检查**: 运行 `cargo clippy` 和 `cargo fmt`
4. **测试验证**: 执行 `cargo test` 确保测试通过
5. **提交代码**: 遵循 Conventional Commits 规范
6. **创建 PR**: 提交 Pull Request 进行代码审查

### 添加新命令

1. **创建命令文件**:
```bash
touch crates/rc-cli/src/commands/新命令.rs
```

2. **实现命令逻辑**:
```rust
// crates/rc-cli/src/commands/新命令.rs
use anyhow::Result;
use std::path::Path;

pub async fn run(/* 参数 */, config_path: &Path) -> Result<()> {
    // 实现命令逻辑
    Ok(())
}
```

3. **注册命令**:
```rust
// crates/rc-cli/src/commands/mod.rs
pub mod 新命令;

// crates/rc-cli/src/main.rs
enum Commands {
    新命令 {
        // 命令参数
    },
}
```

### 调试技巧

#### 启用详细日志
```bash
export ROSETTA_DEBUG_JS=1
export RUST_LOG=debug
cargo run -- your-command --verbose
```

#### 使用 LLDB 调试
```bash
# 构建调试版本
cargo build

# 启动 LLDB
lldb target/debug/rosetta-connect
(lldb) run init --bundle-id com.example.test
```

#### 性能分析
```bash
# 安装性能分析工具
cargo install cargo-profiling

# 运行性能分析
cargo profiling run --bin rosetta-connect
```

---

## 📝 编码规范

### Rust 代码风格

#### 1. 命名约定
```rust
// ✅ 正确
struct AppConfig { ... }
fn load_configuration() -> Result<Config> { ... }
const DEFAULT_TIMEOUT: Duration = Duration::from_secs(30);

// ❌ 错误
struct appconfig { ... }
fn loadConfiguration() -> Result<Config> { ... }
const default_timeout: Duration = Duration::from_secs(30);
```

#### 2. 错误处理
```rust
// ✅ 推荐：使用 anyhow 进行错误传播
fn parse_config(path: &Path) -> anyhow::Result<Config> {
    let content = std::fs::read_to_string(path)
        .with_context(|| format!("无法读取配置文件: {}", path.display()))?;
    
    Ok(toml::from_str(&content)?)
}

// ❌ 避免：不提供上下文的错误处理
fn parse_config(path: &Path) -> Result<Config, Box<dyn std::error::Error>> {
    let content = std::fs::read_to_string(path)?;
    Ok(toml::from_str(&content)?)
}
```

#### 3. 异步代码
```rust
// ✅ 推荐：使用 async/await
async fn fetch_app_info(bundle_id: &str) -> Result<AppInfo> {
    let client = reqwest::Client::new();
    let response = client
        .get(&format!("https://api.appstore.com/apps/{}", bundle_id))
        .send()
        .await?;
    
    response.json().await
}

// ✅ 推荐：并发处理多个任务
async fn process_multiple_locales(locales: Vec<String>) -> Result<()> {
    let tasks: Vec<_> = locales.into_iter()
        .map(|locale| tokio::spawn(process_locale(locale)))
        .collect();
    
    // 等待所有任务完成
    for task in tasks {
        task.await??;
    }
    
    Ok(())
}
```

### 文档标准

#### 1. 模块文档
```rust
//! # 配置管理模块
//! 
//! 本模块负责：
//! - 解析 `rosetta.toml` 配置文件
//! - 提供默认配置值
//! - 支持环境变量覆盖

use serde::{Deserialize, Serialize};
```

#### 2. 函数文档
```rust
/// 从指定路径加载配置文件
/// 
/// # 参数
/// 
/// * `path` - 配置文件路径
/// 
/// # 返回值
/// 
/// 返回解析后的 `Config` 结构体
/// 
/// # 错误
/// 
/// 如果文件不存在或格式错误，返回相应错误
/// 
/// # 示例
/// 
/// ```rust
/// let config = Config::load(Path::new("rosetta.toml"))?;
/// ```
pub fn load(path: &Path) -> anyhow::Result<Config> {
    // 实现
}
```

---

## 🧪 测试策略

### 测试层级

```
┌─────────────────────────────────────┐
│              E2E 测试               │  ← 完整工作流测试
├─────────────────────────────────────┤
│             集成测试                │  ← 模块间交互测试
├─────────────────────────────────────┤
│             单元测试                │  ← 函数级别测试
└─────────────────────────────────────┘
```

### 单元测试

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::TempDir;

    #[test]
    fn test_config_load_success() {
        let temp_dir = TempDir::new().unwrap();
        let config_path = temp_dir.path().join("test.toml");
        
        let config_content = r#"
            [app]
            bundle_id = "com.test.app"
            default_locale = "en-US"
            target_locales = ["zh-Hans"]
        "#;
        
        std::fs::write(&config_path, config_content).unwrap();
        
        let config = Config::load(&config_path).unwrap();
        assert_eq!(config.app.bundle_id, "com.test.app");
    }
    
    #[tokio::test]
    async fn test_async_function() {
        let result = async_function().await;
        assert!(result.is_ok());
    }
}
```

### 集成测试

```rust
// tests/integration_tests.rs
use rosetta_connect::config::Config;
use std::process::Command;

#[test]
fn test_cli_init_command() {
    let output = Command::new("target/debug/rosetta-connect")
        .args(&["init", "--bundle-id", "com.test.app"])
        .output()
        .expect("Failed to execute command");
    
    assert!(output.status.success());
}
```

### 测试运行

```bash
# 运行所有测试
cargo test

# 运行特定模块测试
cargo test config

# 运行集成测试
cargo test --test integration_tests

# 生成测试覆盖率报告
cargo install cargo-tarpaulin
cargo tarpaulin --out Html
```

---

## 🚀 部署和发布

### 构建配置

#### 开发构建
```bash
cargo build --features dev-tools
```

#### 发布构建
```bash
cargo build --release --features bundled-node
```

#### 交叉编译
```bash
# macOS
cargo build --release --target x86_64-apple-darwin
cargo build --release --target aarch64-apple-darwin

# Linux
cargo build --release --target x86_64-unknown-linux-gnu

# Windows
cargo build --release --target x86_64-pc-windows-msvc
```

### CI/CD 配置

#### GitHub Actions 工作流

```yaml
name: CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Install Rust
        uses: actions-rs/toolchain@v1
        with:
          toolchain: stable
      - name: Run tests
        run: cargo test --all-features

  build:
    needs: test
    strategy:
      matrix:
        os: [ubuntu-latest, macos-latest, windows-latest]
    runs-on: ${{ matrix.os }}
    steps:
      - uses: actions/checkout@v3
      - name: Build release
        run: cargo build --release --features bundled-node
      - name: Upload artifacts
        uses: actions/upload-artifact@v3
        with:
          name: rosetta-connect-${{ matrix.os }}
          path: target/release/rosetta-connect*
```

### 发布流程

1. **版本准备**
```bash
# 更新版本号
vim Cargo.toml
vim crates/rc-cli/Cargo.toml

# 更新 CHANGELOG
vim CHANGELOG.md

# 提交版本变更
git add .
git commit -m "chore: bump version to v1.2.0"
```

2. **创建发布标签**
```bash
git tag v1.2.0
git push origin v1.2.0
```

3. **构建和上传**
```bash
# 构建所有平台
./scripts/build-all-platforms.sh

# 创建 GitHub Release
gh release create v1.2.0 \
  --title "Release v1.2.0" \
  --notes-file CHANGELOG.md \
  dist/*
```

---

## 🤝 贡献指南

### 贡献流程

1. **Fork 项目** 到你的 GitHub 账户
2. **创建功能分支** `git checkout -b feature/awesome-feature`
3. **提交变更** `git commit -m 'feat: add awesome feature'`
4. **推送分支** `git push origin feature/awesome-feature`
5. **创建 Pull Request**

### 提交信息规范

我们使用 [Conventional Commits](https://www.conventionalcommits.org/) 规范：

```
<type>[optional scope]: <description>

[optional body]

[optional footer(s)]
```

#### 类型说明

| 类型 | 说明 | 示例 |
|------|------|------|
| `feat` | 新功能 | `feat: add rollback command` |
| `fix` | 错误修复 | `fix: handle timeout in API calls` |
| `docs` | 文档更新 | `docs: update installation guide` |
| `style` | 代码格式 | `style: fix rustfmt warnings` |
| `refactor` | 代码重构 | `refactor: simplify config loading` |
| `test` | 测试相关 | `test: add unit tests for config` |
| `chore` | 构建/工具 | `chore: update dependencies` |

### 代码审查清单

#### Pull Request 检查项

- [ ] 代码遵循项目编码规范
- [ ] 添加了必要的测试用例
- [ ] 测试通过 (`cargo test`)
- [ ] 文档已更新（如适用）
- [ ] 提交信息符合规范
- [ ] 没有引入新的 Clippy 警告
- [ ] 性能没有显著退化

#### 审查者检查项

- [ ] 功能需求是否正确实现
- [ ] 代码设计是否合理
- [ ] 错误处理是否完善
- [ ] 是否遵循最佳实践
- [ ] 是否考虑了边界情况

---

## ❓ 常见问题

### 开发环境问题

#### Q: 编译时出现 "could not find libnode" 错误

**A**: 这通常是因为没有正确配置 Node.js 开发环境。

```bash
# macOS
brew install node

# Ubuntu/Debian
sudo apt-get install nodejs-dev

# 确保环境变量正确设置
export NODE_PATH=$(which node)
export LIBNODE_PATH=/usr/lib/node_modules
```

#### Q: `cargo build` 很慢怎么办？

**A**: 可以通过以下方式优化：

```bash
# 使用 Rust 国内镜像
echo '[source.crates-io]
replace-with = "ustc"

[source.ustc]
registry = "git://mirrors.ustc.edu.cn/crates.io-index"' > ~/.cargo/config

# 并行编译
export CARGO_BUILD_JOBS=4

# 使用 sccache 缓存
cargo install sccache
export RUSTC_WRAPPER=sccache
```

### 运行时问题

#### Q: "Permission denied" 错误

**A**: 确保二进制文件有执行权限：

```bash
chmod +x target/release/rosetta-connect
```

#### Q: API 调用超时

**A**: 检查网络连接和 API 配置：

```bash
# 测试网络连接
curl -I https://api.appstoreconnect.apple.com/

# 增加超时时间
export ROSETTA_API_TIMEOUT=60

# 启用调试模式
export ROSETTA_DEBUG=1
```

### 配置问题

#### Q: `rosetta.toml` 格式错误

**A**: 验证 TOML 格式：

```bash
# 安装 TOML 验证工具
cargo install toml-cli

# 验证配置文件
toml-cli verify rosetta.toml
```

#### Q: AI 翻译质量不好

**A**: 调整 AI 配置参数：

```toml
[ai]
provider = "openai"
model = "gpt-4"  # 使用更强的模型
temperature = 0.3  # 降低随机性
max_tokens = 2048  # 增加输出长度
```

### 性能优化

#### Q: 如何提高翻译速度？

**A**: 使用并发处理：

```rust
// 配置并发数量
const MAX_CONCURRENT_REQUESTS: usize = 10;

// 使用 semaphore 控制并发
let semaphore = Arc::new(Semaphore::new(MAX_CONCURRENT_REQUESTS));
```

#### Q: 内存占用过高

**A**: 分批处理大量数据：

```rust
// 分批处理
const BATCH_SIZE: usize = 100;
for chunk in data.chunks(BATCH_SIZE) {
    process_batch(chunk).await?;
}
```

---

## 📚 扩展阅读

### 相关文档

- [Rust 官方文档](https://doc.rust-lang.org/)
- [Tokio 异步编程指南](https://tokio.rs/tokio/tutorial)
- [App Store Connect API 文档](https://developer.apple.com/documentation/appstoreconnectapi)
- [OpenAI API 文档](https://platform.openai.com/docs)

### 推荐工具

- **开发工具**: [Rust Analyzer](https://rust-analyzer.github.io/), [Cargo Watch](https://github.com/watchexec/cargo-watch)
- **调试工具**: [LLDB](https://lldb.llvm.org/), [GDB](https://www.gnu.org/software/gdb/)
- **性能分析**: [cargo-profiling](https://github.com/svenstaro/cargo-profiling), [Flamegraph](https://github.com/flamegraph-rs/flamegraph)
- **代码质量**: [Clippy](https://github.com/rust-lang/rust-clippy), [Rustfmt](https://github.com/rust-lang/rustfmt)

---

*最后更新: 2024年12月*

*维护者: Rosetta Connect 开发团队*

如有疑问，请在 [GitHub Issues](https://github.com/yourusername/rosetta-connect/issues) 中提出。